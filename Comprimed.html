

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style></style>
    <script src="
    https://cdn.jsdelivr.net/npm/sweetalert2@11.26.1/dist/sweetalert2.all.min.js
"></script>
    <link
      href="
    https://cdn.jsdelivr.net/npm/sweetalert2@11.26.1/dist/sweetalert2.min.css
"
      rel="stylesheet"
    />
    <!-- Título de la aplicación -->
    <title>Tres en Raya</title>
  </head>
  <body>
    <!-- Contenedor donde SweetAlert2 renderiza los modales personalizados -->
    <div class="alertContainer"></div>
    <header class="head">
      <p>
        <span class="player" style="color: red"><b>X</b></span
        >Tres en Raya<span class="player" style="color: blue"><b>O</b></span>
      </p>
    </header>
    <main class="main">
      <!-- Indicador del turno actual -->
      <h1>
        Turno del jugador:
        <span class="player" style="color: red" id="playerToPlayWrapper"
          ><b id="playerToPlay">X</b></span
        >
      </h1>
      <section class="wrapper">
          <article class="game">
          <div class="top left" id="1-1"></div>
          <div class="top center" id="2-1"></div>
          <div class="top right" id="3-1"></div>
          <div class="half left" id="1-2"></div>
          <div class="half center" id="2-2"></div>
          <div class="half right" id="3-2"></div>
          <div class="bott left" id="1-3"></div>
          <div class="bott center" id="2-3"></div>
          <div class="bott right" id="3-3"></div>

          <!-- Líneas de victoria: elementos <i> que se usan para animar la línea ganadora -->

          <i class="victorLine" id="th"></i>
          <i class="victorLine" id="mh"></i>
          <i class="victorLine" id="bh"></i>
          <i class="victorLine" id="lv"></i>
          <i class="victorLine" id="mv"></i>
          <i class="victorLine" id="rv"></i>
          <i class="victorLine" id="ld"></i>
          <i class="victorLine" id="rd"></i>
        </article>
        <article class="stats">
          <header class="headerStats">
            <span style="color: red">X</span><span style="color: blue">O</span>
          </header>
          <section class="wins">
            <div id="x_wins">0</div>
            <div id="o_wins">0</div>
          </section>
        </article>
      </section>
    </main>
    <script type="module">
      const WINNING_LINES = {
    // HORIZONTALES
    TOP_HORIZONTAL: "th",     // Top Horizontal (Fila 0)
    MIDDLE_HORIZONTAL: "mh",  // Middle Horizontal (Fila 1)
    BOTTOM_HORIZONTAL: "bh",  // Bottom Horizontal (Fila 2)
    // VERTICALES
    LEFT_VERTICAL: "lv",      // Left Vertical (Columna 0)
    MIDDLE_VERTICAL: "mv",    // Middle Vertical (Columna 1)
    RIGHT_VERTICAL: "rv",     // Right Vertical (Columna 2)
    // DIAGONALES
    LEFT_DIAGONAL: "ld",      // Left Diagonal (\)
    RIGHT_DIAGONAL: "rd",     // Right Diagonal (/)
};

// --- CASOS DE VICTORIA REFACTORIZADOS Y REORDENADOS ---
// ¡Importante! Los casos complejos (combinaciones) van primero para un chequeo correcto.
export const winCases = [
    // --- COMBINACIONES (2 LÍNEAS) ---
    
    // 6. Dos Diagonales (Victoria central total) - El más complejo
    {
        matrix: [
            [1, 0, 1],
            [0, 1, 0],
            [1, 0, 1],
        ],
        traceLines: [WINNING_LINES.LEFT_DIAGONAL, WINNING_LINES.RIGHT_DIAGONAL],
    },

    // 4. Horizontal + Vertical
    {
        matrix: [
            [1, 1, 1],
            [0, 1, 0],
            [0, 1, 0],
        ],
        traceLines: [WINNING_LINES.TOP_HORIZONTAL, WINNING_LINES.MIDDLE_VERTICAL],
    },
    {
        matrix: [
            [0, 1, 0],
            [1, 1, 1],
            [0, 1, 0],
        ],
        traceLines: [WINNING_LINES.MIDDLE_HORIZONTAL, WINNING_LINES.MIDDLE_VERTICAL],
    },
    {
        matrix: [
            [0, 1, 0],
            [0, 1, 0],
            [1, 1, 1],
        ],
        traceLines: [WINNING_LINES.BOTTOM_HORIZONTAL, WINNING_LINES.MIDDLE_VERTICAL],
    },
    {
        matrix: [
            [1, 0, 0],
            [1, 1, 1],
            [1, 0, 0],
        ],
        traceLines: [WINNING_LINES.LEFT_VERTICAL, WINNING_LINES.MIDDLE_HORIZONTAL],
    },
    {
        matrix: [
            [0, 0, 1],
            [1, 1, 1],
            [0, 0, 1],
        ],
        traceLines: [WINNING_LINES.RIGHT_VERTICAL, WINNING_LINES.MIDDLE_HORIZONTAL],
    },
    
    // 5. Diagonal + Vertical/Horizontal
    {
        matrix: [
            [1, 1, 0],
            [0, 1, 0],
            [0, 1, 1],
        ],
        traceLines: [WINNING_LINES.LEFT_DIAGONAL, WINNING_LINES.MIDDLE_VERTICAL],
    },
    {
        matrix: [
            [0, 1, 1],
            [0, 1, 0],
            [1, 1, 0],
        ],
        traceLines: [WINNING_LINES.RIGHT_DIAGONAL, WINNING_LINES.MIDDLE_VERTICAL],
    },
    {
        matrix: [
            [0, 0, 1],
            [1, 1, 1],
            [1, 0, 0],
        ],
        traceLines: [WINNING_LINES.RIGHT_DIAGONAL, WINNING_LINES.MIDDLE_HORIZONTAL],
    },
    {
        matrix: [
            [1, 0, 0],
            [1, 1, 1],
            [0, 0, 1],
        ],
        traceLines: [WINNING_LINES.LEFT_DIAGONAL, WINNING_LINES.MIDDLE_HORIZONTAL],
    },
    //6. lineas horizontales de izquierda, derecha + lineas verticales izquierda, derecha
    {
        matrix: [
            [1,1,1],
            [1,0,0],
            [1,0,0]
        ],
        traceLines: [WINNING_LINES.LEFT_VERTICAL, WINNING_LINES.TOP_HORIZONTAL]
    },
    {
         matrix: [
            [1,0,0],
            [1,0,0],
            [1,1,1]
        ],
        traceLines: [WINNING_LINES.LEFT_VERTICAL, WINNING_LINES.BOTTOM_HORIZONTAL]
    },
    {
         matrix: [
            [0,0,1],
            [0,0,1],
            [1,1,1]
        ],
        traceLines: [WINNING_LINES.RIGHT_VERTICAL, WINNING_LINES.BOTTOM_HORIZONTAL]
    },
    {
         matrix: [
            [1,1,1],
            [0,0,1],
            [0,0,1]
        ],
        traceLines: [WINNING_LINES.RIGHT_VERTICAL, WINNING_LINES.TOP_HORIZONTAL]
    },
    // --- CASOS SIMPLES (1 LÍNEA) ---

    // 1. HORIZONTALES SIMPLES
    {
        matrix: [
            [1, 1, 1],
            [0, 0, 0],
            [0, 0, 0],
        ],
        traceLines: [WINNING_LINES.TOP_HORIZONTAL],
    },
    {
        matrix: [
            [0, 0, 0],
            [1, 1, 1],
            [0, 0, 0],
        ],
        traceLines: [WINNING_LINES.MIDDLE_HORIZONTAL],
    },
    {
        matrix: [
            [0, 0, 0],
            [0, 0, 0],
            [1, 1, 1],
        ],
        traceLines: [WINNING_LINES.BOTTOM_HORIZONTAL],
    },
    
    // 2. VERTICALES SIMPLES
    {
        matrix: [
            [1, 0, 0],
            [1, 0, 0],
            [1, 0, 0],
        ],
        traceLines: [WINNING_LINES.LEFT_VERTICAL],
    },
    {
        matrix: [
            [0, 1, 0],
            [0, 1, 0],
            [0, 1, 0],
        ],
        traceLines: [WINNING_LINES.MIDDLE_VERTICAL],
    },
    {
        matrix: [
            [0, 0, 1],
            [0, 0, 1],
            [0, 0, 1],
        ],
        traceLines: [WINNING_LINES.RIGHT_VERTICAL],
    },
    
    // 3. DIAGONALES SIMPLES
    {
        matrix: [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1],
        ],
        traceLines: [WINNING_LINES.LEFT_DIAGONAL],
    },
    {
        matrix: [
            [0, 0, 1],
            [0, 1, 0],
            [1, 0, 0],
        ],
        traceLines: [WINNING_LINES.RIGHT_DIAGONAL],
    },
];
      class Move {
  constructor(player, cords) {
    this.player = player;
    this.cords = cords;
  }
  render(parentElement) {
    // Obtener las 9 casillas del tablero (dominio del juego)
    const boxes =
      parentElement.querySelectorAll("div") ||
      document.querySelectorAll(".game div");
    // Convertir NodeList a una matriz 3x3 para indexado [fila][col]
    const boxesMatrix = [
      [...boxes].slice(0, 3),
      [...boxes].slice(3, 6),
      [...boxes].slice(6, 9),
    ];

    let [box_x, box_y] = this.cords.split("-");
    box_x = parseInt(box_x);
    box_y = parseInt(box_y);

    const boxElement = boxesMatrix[box_y - 1][box_x - 1];
    // Si la casilla ya tiene contenido, no renderizar (seguridad adicional)
    if (boxElement.innerHTML != "") return;

    const moveContainerElement = document.createElement("span");

    moveContainerElement.innerHTML = this.player;
    moveContainerElement.style.color = this.player === "X" ? "red" : "blue";

    boxElement.appendChild(moveContainerElement);
class Game {
  constructor(parentElement) {
    this.parentElement = parentElement; // elemento DOM que representa el tablero
    this._moves = []; // array de objetos Move
    this._winner = ""; // "X" | "O" | "" (si no hay ganador)
    this._winLines = []; // ids de las líneas de victoria para animar
    // Matriz interna (fila y columna) indexada [fila][col]
    this._matrix = [
      ["", "", ""],
      ["", "", ""],
      ["", "", ""],
    ];
  }

  // Restablece el tablero a su estado inicial y limpia animaciones/contadores
  _reset() {
    const boxes = this.parentElement.querySelectorAll("div");
    boxes.forEach((box) => (box.textContent = ""));

    this._matrix = [
      ["", "", ""],
      ["", "", ""],
      ["", "", ""],
    ];

    // Quitar clase de animación a las líneas de victoria
    this._winLines.forEach((winLine) =>
      document.getElementById(winLine).classList.remove("apper")
    );
    this._winLines = [];
    this._moves = [];
    this._winner = "";
  }

  // Revisa si alguna de las combinaciones de winCases está presente
  _checkWinner() {
    // Convertir la matriz a dos representaciones binarias para X y O
    const parsedArrayX = this._matrix.map((e) => {
      return e.map((i) => {
        const moveToBin = i == "X" ? 1 : 0;
        return moveToBin;
      });
    });
    const parsedArrayO = this._matrix.map((e) => {
      return e.map((i) => {
        const moveToBin = i == "O" ? 1 : 0;
        return moveToBin;
      });
    });

    // Iterar sobre los casos de victoria definidos y comprobar coincidencias
    return winCases.some((winCaseObj) => {
      const winCase = winCaseObj.matrix;

      // Calcular índices activos (coordenadas) del winCase
      let activeIndexes = [];
      winCase.forEach((row, rowIdx) => {
        row.forEach((e, numIdx) => {
          if (e == 1) activeIndexes.push(`${numIdx}-${rowIdx}`);
        });
      });

      // Contar coincidencias para X
      let matchesX = 0;
      activeIndexes.forEach((cordinate) => {
        const x = cordinate.split("-")[0];
        const y = cordinate.split("-")[1];

        if (parsedArrayX[y][x] == winCase[y][x]) matchesX++;
      });

      // Contar coincidencias para O
      let matchesO = 0;
      activeIndexes.forEach((cordinate) => {
        const x = cordinate.split("-")[0];
        const y = cordinate.split("-")[1];

        if (parsedArrayO[y][x] == winCase[y][x]) matchesO++;
      });

      const isWinnerCase =
        matchesX == activeIndexes.length || matchesO == activeIndexes.length;
      if (isWinnerCase) this._winLines = winCaseObj.traceLines; // guardar líneas para animación
      return isWinnerCase;
    });
  }

  // Intenta registrar un movimiento.
  // Retorna false si la casilla ya está ocupada; true si se aplicó correctamente.
  setMove(move) {
    if (this._moves.some((moveMade) => moveMade.cords == move.cords))
      return false; // movimiento inválido (coordenada ya ocupada)

    this._moves.push(move);

    let [moveX, moveY] = move.cords.split("-");
    moveX = parseInt(moveX);
    moveY = parseInt(moveY);

    // Actualizar matriz interna
    this._matrix[moveY - 1][moveX - 1] = move.player;
    // Renderizar en DOM
    move.render(this.parentElement);

    const posibleWinnerPlayer = this._moves[this._moves.length - 1].player;

    // Comprobar ganador y, si existe, asignarlo
    if (this._checkWinner()) this._winner = posibleWinnerPlayer;

    return true;
  }
}
const board = document.querySelector(".game");
const boxesList = board.querySelectorAll("div");
const playerToPlayWrapper = document.getElementById("playerToPlayWrapper");
const playerToPlay = document.getElementById("playerToPlay");
const x_winsElement = document.getElementById("x_wins");
const o_winsElement = document.getElementById("o_wins");
const mainGame = new Game(board);

let turn = "X";
let isAWinner = false;

// Utilidad: pausa asincrónica usada para animaciones/retardos visuales
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

/**
 * handleClick
 * - Manejador del evento 'click' sobre cada casilla del tablero.
 * - Crea una instancia Move con el turno actual y las coordenadas (id de la casilla).
 * - Intenta aplicar el movimiento usando mainGame.setMove(move).
 * - Si el movimiento es válido: cambia el turno visualmente y maneja
 *   el caso de victoria (animación de líneas, swal y reinicio parcial).
 * - También maneja el caso de empate cuando _moves alcanza 9 movimientos.
 */
const handleClick = async (e) => {
  // Si ya hay un ganador, ignorar nuevos clicks
  if (isAWinner) return;

  const box = e.target;
  let boxCords = box.id; // ejemplo: "2-1"
  const move = new Move(turn, boxCords);

  // setMove realiza la validación y render del movimiento.
  const isValid = mainGame.setMove(move);
  if (isValid) {
    // Alternar turno
    turn = turn == "X" ? "O" : "X";

    // Si aún no hay un ganador, actualizar indicador de turno
    if (!mainGame._winner) {
      playerToPlayWrapper.style.color = turn == "X" ? "red" : "blue";
      playerToPlay.textContent = turn;
    } else {
      // Se detectó un ganador: bloquear interacciones y animar líneas
      isAWinner = true;
      const traceLinesElements = mainGame._winLines.map((line) =>
        document.getElementById(line)
      );

      // Pintar y animar cada línea de victoria encontrada
      for (let element of traceLinesElements) {
        // nota: el 'turn' ya cambió, por eso la verificación inversa
        element.style.backgroundColor = turn == "O" ? "red" : "blue";
        element.classList.add("apper");

        await delay(800); // pausa para mostrar cada línea secuencialmente
      }
      await delay(100);

      // Mostrar modal con SweetAlert2 y, al confirmar, actualizar contadores y reiniciar
      swal
        .fire({
          title: "GANO EL JUGADOR:",
          html: `<span class="swalDesc" style="color:${
            mainGame._winner == "X" ? "red" : "blue"
          }">${mainGame._winner}</span>`,
          target: ".alertContainer",
          confirmButtonText: "Reiniciar",
          customClass: {
            popup: "swalPopup",
          },
        })
        .then(() => {
          if (mainGame._winner == "X")
            x_winsElement.textContent = parseInt(x_winsElement.textContent) + 1;
          if (mainGame._winner == "O")
            o_winsElement.textContent = parseInt(o_winsElement.textContent) + 1;

          mainGame._reset();
          // permitir nuevos clicks
          isAWinner = !isAWinner;
        });

      // Actualizar indicador de turno (queda el turno alternado)
      playerToPlayWrapper.style.color = turn == "X" ? "red" : "blue";
      playerToPlay.textContent = turn;
    }
  }

  // Empate: 9 movimientos y sin ganador
  if (mainGame._moves.length === 9 && !mainGame._winner) {
    swal
      .fire({
        title: "EMPATE",
        target: ".alertContainer",
        confirmButtonText: "Reiniciar",
        customClass: {
          popup: "swalPopup",
        },
      })
      .then(() => {
        mainGame._reset();
      });
  }
};

boxesList.forEach((e) => e.addEventListener("click", handleClick));
    </script>
  </body>
</html>
